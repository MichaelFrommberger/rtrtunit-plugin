package com.thalesgroup.rtrtunit;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;

import com.thalesgroup.dtkit.junit.model.JUnitModel;
import com.thalesgroup.dtkit.metrics.model.InputMetricOther;
import com.thalesgroup.dtkit.metrics.model.InputType;
import com.thalesgroup.dtkit.metrics.model.OutputMetric;
import com.thalesgroup.dtkit.util.converter.ConversionException;
import com.thalesgroup.dtkit.util.validator.ValidationError;
import com.thalesgroup.dtkit.util.validator.ValidationException;
import com.thalesgroup.dtkit.util.validator.ValidationService;
import com.thalesgroup.rtrtunit.converter.RTRTtoXMLConverter;
import com.thalesgroup.rtrtunit.riochecker.SyntaxRioChecker;
import com.thalesgroup.rtrtunit.tdcreader.TdcException;

/**
 * RTRTUnitInputMetric.
 * @author Sebastien Barbier
 * @version 1.0
 */
public class RTRTUnitInputMetric extends InputMetricOther {

    /**
     * Get InputType.
     * @return InputType.TEST
     */
    @Override
    public final InputType getToolType() {
        return InputType.TEST;
    }

    /**
     * Return Name of the plugin.
     * @return name of the plugin
     */
    @Override
    public final String getToolName() {
        return "RTRTUnit";
    }

    /**
     * Return version.
     * @return version of the plugin
     */
    @Override
    public final String getToolVersion() {
        return "1.0";
    }

    /**
     * Conversion of the input toward the output.
     * @param inputRIOFile the .rio file
     * @param outXMLFile the junit xml report
     * @param map useless
     */
    @Override
    public final void convert(final File inputRIOFile, final File outXMLFile,
            final Map<String, Object> map) {

        RTRTtoXMLConverter converter = null;
        try {
            converter = new RTRTtoXMLConverter(inputRIOFile, outXMLFile);
        } catch (TdcException e) {
            throw new ConversionException(e.getMessage());
        } catch (IOException e) {
            throw new ConversionException(e.getMessage());
        }

        converter.buildHeader();
        try {
            converter.buildTests();
        } catch (TdcException e) {
            throw new ConversionException(e.getMessage());
        }
        converter.writeXML();
    }

    /**
     * Validation of the .rio file according to the RioGrammar.jj. Skip if an
     * .err file exists.
     * @param inputFile the .rio file
     * @return true if the file is correct
     * @see SyntaxRioChecker
     */
    @Override
    public final boolean validateInputFile(final File inputFile) {
        InputStream is = null;

        try {
            is = new FileInputStream(inputFile);
        } catch (FileNotFoundException e) {
            throw new ValidationException("The file "
                    + inputFile.getAbsolutePath() + " cannot be read");
        }
        String nameTest = inputFile.getAbsolutePath().substring(0,
                inputFile.getAbsolutePath().lastIndexOf('.'));
        File errFile = new File(nameTest + ".err");

        if (errFile.exists()) {
            return true;
        }

        boolean validation = false;
        try {
            validation = new SyntaxRioChecker(is).validate();
        } catch (Exception e) {
            throw new ValidationException(e);
        }
        return validation;
    }

    /**
     * Validation of the junit report xml file according to the junit.xsd.
     * @param inputXMLFile : the junit report xml file generated by our
     *            converter
     * @return true if the file is correct Based on the .xsd file
     */
    @Override
    public final boolean validateOutputFile(final File inputXMLFile) {
        // Give the .xsd file included into the resource path.
        Source source = new StreamSource(getOutputFormatType().getClass()
                .getResourceAsStream("xsd/junit-1.0.xsd"));

        // Apply the processValidation already encoded into the dtkit and check
        // if some errors.
        List<ValidationError> lve = new ValidationService().processValidation(
                source, inputXMLFile);
        for (ValidationError ve : lve) {
            throw new ValidationException(ve.toString());
        }

        // No error => validation is ok!
        return lve.isEmpty();
    }

    /**
     * Get OutputType.
     * @return OutputType.JUNIT_1
     */
    @Override
    public final OutputMetric getOutputFormatType() {
        return JUnitModel.OUTPUT_JUNIT_1_0;
    }

}
